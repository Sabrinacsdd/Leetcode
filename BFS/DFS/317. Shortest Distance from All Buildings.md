## LeetCode link(Hard)
https://leetcode.com/problems/shortest-distance-from-all-buildings/

## Keyword
String

## Problem description
```
You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:

Each 0 marks an empty land which you can pass by freely.
Each 1 marks a building which you cannot pass through.
Each 2 marks an obstacle which you cannot pass through.
Example:

Input: [[1,0,2,0,1],[0,0,0,0,0],[0,0,1,0,0]]

1 - 0 - 2 - 0 - 1
|   |   |   |   |
0 - 0 - 0 - 0 - 0
|   |   |   |   |
0 - 0 - 1 - 0 - 0

Output: 7 

Explanation: Given three buildings at (0,0), (0,4), (2,2), and an obstacle at (0,2),
             the point (1,2) is an ideal empty land to build a house, as the total 
             travel distance of 3+3+1=7 is minimal. So return 7.
Note:
There will be at least one building. If it is not possible to build such house according to the above rules, return -1.
```



## Notes


## Things to watchout

## 07/21/20 Java

```java
class Solution {
    public int shortestDistance(int[][] grid) {
        int n = grid.length;
        int m = grid[0].length;
        int ans = Integer.MAX_VALUE;
        int[] dx = {0, 1, 0, -1};
        int[] dy = {1, 0, -1, 0};
        //total buildings I need to reach
        int total = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] == 1) {
                    ++total;
                }
            }
        }
        //traverse all the "0" grid, try to build the buildings;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (grid[i][j] != 0) {
                    continue;
                }
                //check the distance if build the building at current point
                int cur = 0; // cur is the distance in total to reach all the buildings
                int count = 0; // how many buildings have been reached so far
                boolean[][] seen = new boolean[n][m]; // the position have been reached to avoid duplicate
                
                Queue<int[]> q = new LinkedList<>();
                q.add(new int[]{i, j});
                seen[i][j] = true;
                int step = 0; // the step need to reach the current position;
                while (!q.isEmpty()) {
                    int size = q.size();
                    while (size-- > 0) {
                        int[] curr = q.poll();
                        int x = curr[0];
                        int y = curr[1];
                        if (grid[x][y] == 1) {
                            ++count;
                            cur += step;
                            if (count == total) {
                                ans = Math.min(ans, cur);
                                break;
                            }
                            continue;
                        }
                        
                        //check next movement
                        for (int k = 0; k < 4; ++k) {
                            int nextx = x + dx[k];
                            int nexty = y + dy[k];
                            if (nextx < 0 || nexty < 0 || nextx >= n || nexty >= m || seen[nextx][nexty] == true || grid[nextx][nexty] == 2) {
                                continue;
                            }
                            //if valid, add to the queue
                            seen[nextx][nexty] = true;
                            q.add(new int[]{nextx, nexty});
                        }
                    }
                    ++step;
                }
                
            }
        }
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
}

```
## Complexity Analyze
Time: O(m * n * m * n)       \
Space: O(m * n)